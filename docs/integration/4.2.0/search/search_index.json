{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mobile paymentSDK Integration Guide for Android \u00b6 Introduction \u00b6 Mobile paymentSDK is divided into a core module and several secondary modules, one for each payment method. With this modular approach, you can pick and choose what you need: a few payment methods (or even just one) or the full selection. You can also exclude features of an individual module (e.g. IBAN scanner). Below, we will briefly go through the basic requirements/dependencies, but also code examples for client initialization and processing the payment response on your end. System Requirements \u00b6 The minimal requirement is Android API level 16 (4.1 Jelly Bean), but 20 (4.4.4 KitKat) is recommended for additional security (TLS). Device Requirements \u00b6 The IBAN and card number scanning features require a camera with autofocus. If you don't need these features, there are no further requirements. Basic Setup \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } Proguard Rules \u00b6 Each module has a defined set of Proguard rules. They load automatically once you've enabled code obfuscation in your app. This means you can see logs and debug the application until you enable the obfuscation. You do not need to define any further rules. Client Initialization \u00b6 When creating a payment object, don't forget to initialize the client first: Kotlin 1 2 3 4 5 6 7 8 9 // initialization with context val client = Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ) // initialization with android.support.v4.app.Fragment val client = Client ( fragment , \"https://api-test.wirecard.com\" , requestTimeout ) //or val client = Client ( context , \"https://api-test.wirecard.com\" ) // default timeout is set to 30 seconds Java 1 2 3 4 5 6 7 8 Client client = new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ); // initialization with android.support.v4.app.Fragment Client client = Client ( fragment , \"https://api-test.wirecard.com\" , requestTimeout ); //or Client client = new Client ( context , \"https://api-test.wirecard.com\" ); // default timeout is set to 30 seconds For a successful initialization, Client requires Context or android.support.v4.app.Fragment instance, Wirecard payment gateway URL address and Timeout (in seconds). Check the SDK javadoc for details about the constructor and other parameters. Processing the response \u00b6 This is example code for processing the response (to see the result of the transaction), after the payment goes through: Kotlin 1 2 3 4 5 6 7 8 9 override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val paymentSdkResponse = data ?. getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { Toast . makeText ( this , \"Response code: ${paymentSdkResponse.responseCode} ${paymentSdkResponse.errorMessage} ${paymentSdkResponse.payment?.statuses?.print()}\" , Toast . LENGTH_SHORT ). show () Log . i ( \"response\" , \"${paymentSdkResponse.payment.toString()} ${paymentSdkResponse.throwable?.cause}\" ) } } Java 1 2 3 4 5 6 7 8 @Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { String formattedResponse = ResponseHelper . getFormattedResponse ( paymentSdkResponse ); Toast . makeText ( this , formattedResponse , Toast . LENGTH_SHORT ). show (); } } PaymentResponse Object Reference \u00b6 This is the PaymentResponse object model: responseCode : Int - Returns a response code (documented below) payment : Payment - Actual payment response (returned only on success) errorMessage : String - Error message throwable : Throwable - Returned for exceptions Response codes \u00b6 This is a list of available response codes and their meaning: RESULT_OK - Returned after a successful payment ERROR_CODE_GENERAL - An exception or another unspecified error ( Throwable is part of the ResponseWrapper ) ERROR_CODE_INVALID_PAYMENT_DATA - Provided payment data are invalid ERROR_CODE_USER_CANCELED - User has canceled the payment ERROR_CODE_ROOTED_DEVICE - Client check for rooted device ERROR_CODE_NETWORK_ISSUE - No internet connection, certificate issue or other network related issue ERROR_CODE_TRANSACTION_TIMEOUT - Payment session has timed out ERROR_CODE_TRANSACTION_RETRY - User has retried a payment (ZAPP payment method only) Error Handling \u00b6 The SDK uses default exceptions only. If you decide to use Kotlin, the SDK provides a null check within the IDE (if a field is null, IllegalArgumentException is thrown). We recommend using a try-catch block for SDK initialization and starting a payment using the startPayment() method: both actions throw a RuntimeException .","title":"Start Here"},{"location":"#mobile-paymentsdk-integration-guide-for-android","text":"","title":"Mobile paymentSDK Integration Guide for Android"},{"location":"#introduction","text":"Mobile paymentSDK is divided into a core module and several secondary modules, one for each payment method. With this modular approach, you can pick and choose what you need: a few payment methods (or even just one) or the full selection. You can also exclude features of an individual module (e.g. IBAN scanner). Below, we will briefly go through the basic requirements/dependencies, but also code examples for client initialization and processing the payment response on your end.","title":"Introduction"},{"location":"#system-requirements","text":"The minimal requirement is Android API level 16 (4.1 Jelly Bean), but 20 (4.4.4 KitKat) is recommended for additional security (TLS).","title":"System Requirements"},{"location":"#device-requirements","text":"The IBAN and card number scanning features require a camera with autofocus. If you don't need these features, there are no further requirements.","title":"Device Requirements"},{"location":"#basic-setup","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } }","title":"Basic Setup"},{"location":"#proguard-rules","text":"Each module has a defined set of Proguard rules. They load automatically once you've enabled code obfuscation in your app. This means you can see logs and debug the application until you enable the obfuscation. You do not need to define any further rules.","title":"Proguard Rules"},{"location":"#client-initialization","text":"When creating a payment object, don't forget to initialize the client first: Kotlin 1 2 3 4 5 6 7 8 9 // initialization with context val client = Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ) // initialization with android.support.v4.app.Fragment val client = Client ( fragment , \"https://api-test.wirecard.com\" , requestTimeout ) //or val client = Client ( context , \"https://api-test.wirecard.com\" ) // default timeout is set to 30 seconds Java 1 2 3 4 5 6 7 8 Client client = new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ); // initialization with android.support.v4.app.Fragment Client client = Client ( fragment , \"https://api-test.wirecard.com\" , requestTimeout ); //or Client client = new Client ( context , \"https://api-test.wirecard.com\" ); // default timeout is set to 30 seconds For a successful initialization, Client requires Context or android.support.v4.app.Fragment instance, Wirecard payment gateway URL address and Timeout (in seconds). Check the SDK javadoc for details about the constructor and other parameters.","title":"Client Initialization"},{"location":"#processing-the-response","text":"This is example code for processing the response (to see the result of the transaction), after the payment goes through: Kotlin 1 2 3 4 5 6 7 8 9 override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val paymentSdkResponse = data ?. getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { Toast . makeText ( this , \"Response code: ${paymentSdkResponse.responseCode} ${paymentSdkResponse.errorMessage} ${paymentSdkResponse.payment?.statuses?.print()}\" , Toast . LENGTH_SHORT ). show () Log . i ( \"response\" , \"${paymentSdkResponse.payment.toString()} ${paymentSdkResponse.throwable?.cause}\" ) } } Java 1 2 3 4 5 6 7 8 @Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { String formattedResponse = ResponseHelper . getFormattedResponse ( paymentSdkResponse ); Toast . makeText ( this , formattedResponse , Toast . LENGTH_SHORT ). show (); } }","title":"Processing the response"},{"location":"#paymentresponse-object-reference","text":"This is the PaymentResponse object model: responseCode : Int - Returns a response code (documented below) payment : Payment - Actual payment response (returned only on success) errorMessage : String - Error message throwable : Throwable - Returned for exceptions","title":"PaymentResponse Object Reference"},{"location":"#response-codes","text":"This is a list of available response codes and their meaning: RESULT_OK - Returned after a successful payment ERROR_CODE_GENERAL - An exception or another unspecified error ( Throwable is part of the ResponseWrapper ) ERROR_CODE_INVALID_PAYMENT_DATA - Provided payment data are invalid ERROR_CODE_USER_CANCELED - User has canceled the payment ERROR_CODE_ROOTED_DEVICE - Client check for rooted device ERROR_CODE_NETWORK_ISSUE - No internet connection, certificate issue or other network related issue ERROR_CODE_TRANSACTION_TIMEOUT - Payment session has timed out ERROR_CODE_TRANSACTION_RETRY - User has retried a payment (ZAPP payment method only)","title":"Response codes"},{"location":"#error-handling","text":"The SDK uses default exceptions only. If you decide to use Kotlin, the SDK provides a null check within the IDE (if a field is null, IllegalArgumentException is thrown). We recommend using a try-catch block for SDK initialization and starting a payment using the startPayment() method: both actions throw a RuntimeException .","title":"Error Handling"},{"location":"Card_Payments/","text":"Card Payments \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types: purchase - charges the account holder's card and immediately transfers the reserved amount. authorization-only - verifies the validity of account holder's card, but does not leave an authorized amount. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. referenced-purchase - charges the account holder's card and immediately transfers the reserved amount. References a previous purchase transaction. referenced-authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. References a previous authorization transaction. capture-authorization - captures a previously authorized amount from the account holder's card. Must refer to an existing authorization transaction. tokenize - provides a unique token which represents the tokenized card data. This token then can be used in future transactions. enrollment - provides card enrollment with loyalty card support. Loyalty card data must be provided. This transaction type must be done without requested amount/currency Supported Card Brands \u00b6 As of version 4.2.0 the Card Brand CUP has been deprecated and got replaced by UPI. Make sure to switch to new card type and do not use UPI a CUP together (this will throw PaymentException). Default Card Brands \u00b6 Card brand CB is supported but disabled by default, please add manually using dedicated method (setSupportedCardBrands()) to enable CB card brand. Signature \u00b6 Application shall get signature from server where signature shall be computed. Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation ( \"com.wirecard.ecom:card:4.2.0\" ) { // uncomment exclude module in case you would like to disable card scanning feature // exclude module: 'play-services-vision' } ... } To disable the card scanner feature, uncomment the exclude module line. When adding/removing this feature, perform a full clean build. If you intend to use Card Payments module together with the SEPA Direct Debit module (with enabled IBAN scanner), you must enable it in both modules. Basic Card Payment \u00b6 This is a code example for a basic card payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , amount , currency ) // for enabling animated card layout cardPayment . animatedCardPayment = true // force 3D Secure attempt cardPayment . attempt3d = true Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . build (); // for enabling animated card layout cardPayment . setAnimatedCardPayment ( true ); // force 3D Secure attempt cardPayment . setAttempt3d ( true ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ); Note: You can set additional parameters after the payment object is created. Check the API documentation for more details. Token payment \u00b6 This is a code example for a card payment which uses a card token (obtained from a previous transaction): Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , amount , currency ) // for enabling animated card layout cardPayment . animatedCardPayment = true val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken cardToken . tokenUsageIndicator = true cardToken . requireSecurityCode = true Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . build (); // for enabling animated card layout cardPayment . setAnimatedCardPayment ( true ); CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . setCardToken ( cardToken ); cardPayment . setRequireSecurityCode ( true ); cardPayment . setTokenUsageIndicator ( true ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ); Card enrollment \u00b6 This transaction must be done without providing amount/currency within the request body. Mandatory field in the request is one of following: - accountHolder.email - This is the end-consumer\u2019s email-address. - accountHolder.phone - This is the phone number of the end-consumer. - consumerId - This is the end-consumer's identifier. The consumerId is mandatory for Enroll Card With Token This is a code example for a card enrollment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // be sure to NOT provide amount and currency val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , null , null ) // for providing mandatory field val customerData = AccountHolder () customerData . lastName = \"Doe\" customerData . email = \"john.doe@gmail.com\" // and/or customerData . phone = \"+421905555555\" cardPayment . accountHolder = customerData // or providing consumerId instead of AccountHolder's fields cardPayment . consumerId = \"1234567\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // be sure to NOT provide amount and currency CardPayment cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . build (); // for providing mandatory field AccountHolder customerData = AccountHolder (); customerData . setLastName ( \"Doe\" ); customerData . setEmail ( \"john.doe@gmail.com\" ); // and/or customerData . setPhone ( \"+421905555555\" ); cardPayment . setAccountHolder ( customerData ); // or providing consumerId instead of AccountHolder's fields cardPayment . setConsumerId ( \"1234567\" ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ); Note: For token based enrollment refer to Token payment. As mentioned above the consumerId is mandatory and must be provided within the CardPayment object. Adding card can be done using LoyaltyCard.userId property in the CardPayment object. Card Field \u00b6 Card Field is a feature where card information (card number, expiration date and CVV) is entered into a single, dynamically changing field instead of multiple separate ones. Here's example code for a card payment using this feature: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class KotlinCardFieldActivity : AppCompatActivity (), Observer < PaymentResponse > { private val mContext = this private val mPaymentObjectProvider = PaymentObjectProvider () private lateinit var cardFieldFragment : CardFieldFragment override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_card_form ) cardFieldFragment = CardFieldFragment . Builder (). build () supportFragmentManager . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit () cardFieldFragment . getEventObserver () . subscribe { state -> Log . i ( \"event\" , state . toString ()) } } fun onSubmitButtonClicked ( view : View ) { if ( cardFieldFragment . getCardBundle () != null ) { Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())) findViewById < View >( R . id . progress ). visibility = View . VISIBLE } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show () } } fun getCardFormPayment ( cardBundle : CardBundle ): CardFormPayment { val merchantID = \"merchant_id\" val secretKey = \"secret_key\" val requestID = UUID . randomUUID (). toString () val transactionType = TransactionType . PURCHASE val amount = BigDecimal ( 5 ) val currency = \"EUR\" val signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . value , amount , currency , secretKey ) val cardFormPayment = CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build () val accountHolder = AccountHolder ( \"John\" , \"Doe\" ) cardFormPayment . accountHolder = accountHolder return cardFormPayment } override fun onObserve ( paymentResponse : PaymentResponse ) { runOnUiThread { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show () findViewById < View >( R . id . progress ). visibility = View . GONE } } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class CardFieldActivity extends AppCompatActivity implements Observer < PaymentResponse > { private Context mContext = this ; private PaymentObjectProvider mPaymentObjectProvider = new PaymentObjectProvider (); CardFieldFragment cardFieldFragment ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_card_form ); cardFieldFragment = new CardFieldFragment . Builder (). build (); getSupportFragmentManager () . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit (); cardFieldFragment . getEventObserver () . subscribe ( state -> { Log . i ( \"event\" , state . toString ()); } ); } public void onSubmitButtonClicked ( View view ) { if ( cardFieldFragment . getCardBundle () != null ) { new Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())); findViewById ( R . id . progress ). setVisibility ( View . VISIBLE ); } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show (); } } public CardFormPayment getCardFormPayment ( CardBundle cardBundle ) { String merchantID = \"merchant_id\" ; String secretKey = \"secret_key\" ; String requestID = UUID . randomUUID (). toString (); TransactionType transactionType = TransactionType . PURCHASE ; BigDecimal amount = new BigDecimal ( 5 ); String currency = \"EUR\" ; String signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . getValue (), amount , currency , secretKey ); CardFormPayment cardFormPayment = new CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build (); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); cardFormPayment . setAccountHolder ( accountHolder ); return cardFormPayment ; } @Override public void onObserve ( PaymentResponse paymentResponse ) { runOnUiThread (() -> { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show (); findViewById ( R . id . progress ). setVisibility ( View . GONE ); } ); } } Client can be initialized with android.support.v4.app.Fragment instance as well. The response is being handled similar as example above by implementing Observer in your android.support.v4.app.Fragment class. For more information and example refer to CardFieldFragmentImplFragment implementation in example application. Additional Options for Card Field \u00b6 You can set additional options for Card Field through CardFieldFragment.Builder : SetSupportedCardBrands - sets allowed card brands (providers) setExpirationDate - used in token payments setRequestFocus - sets screen focus (after the card form loads) setHideCardIcon - hides provider icons (VISA, Maestro, etc.) setToken - used in token payments setMaskedCardNumber - used in token payments setCardBrand - sets the card brand/provider setTextSize - changes text size setLocale - changes the payment locale setNativeLocale - changes the payment locale (UI only) Token Payment with Card Field \u00b6 The payment object is identical to a normal card field payment (like the example above), but you need to include the card token. Kotlin 1 2 3 4 5 6 7 8 ... val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken ... cardFieldBuilder . setToken ( cardToken . tokenId ) cardFieldBuilder . setCardBrand ( CardBrand . VISA ) ... Java 1 2 3 4 5 6 7 8 ... CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . cardToken = cardToken ; ... cardPayment . setCardToken ( cardToken ); cardFieldBuilder . setCardBrand ( CardBrand . VISA ); ... Animated Card Field \u00b6 Animated Card Field is a feature where card information (card number, expiration date and CVV) is entered into a single, dynamically changing field with animated representation of the card. Here's example code for a card payment using this feature: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class KotlinAnimatedCardFieldActivity : AppCompatActivity (), Observer < PaymentResponse > { private val mContext = this private lateinit var animatedCardFieldFragment : AnimatedCardFieldFragment override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_animated_card_form ) animatedCardFieldFragment = AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . build () supportFragmentManager . beginTransaction () . add ( R . id . card_field_container , animatedCardFieldFragment ) . commit () animatedCardFieldFragment . getEventObserver () . subscribe { state -> Log . i ( \"event\" , state . toString ()) } } fun onSubmitButtonClicked ( view : View ) { if ( animatedCardFieldFragment . getCardBundle () != null ) { Client ( this , URL_EE_TEST , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( animatedCardFieldFragment . getCardBundle ())) findViewById < View >( R . id . progress ). visibility = View . VISIBLE } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show () } } fun getCardFormPayment ( cardBundle : CardBundle ?): CardFieldPayment { val timestamp = SignatureHelper . generateTimestamp () val merchantID = \"33f6d473-3036-4ca5-acb5-8c64dac862d1\" val secretKey = \"9e0130f6-2e1e-4185-b0d5-dc69079c75cc\" val requestID = UUID . randomUUID (). toString () val transactionType = TransactionType . PURCHASE val amount = BigDecimal ( 5 ) val currency = \"EUR\" val signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . value , amount , currency , secretKey ) val cardFieldPayment = CardFieldPayment . Builder () . setSignature ( signature !! ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle !! ) . build () val accountHolder = AccountHolder ( \"John\" , \"Doe\" ) cardFieldPayment . accountHolder = accountHolder return cardFieldPayment } override fun onObserve ( paymentResponse : PaymentResponse ) { runOnUiThread { Toast . makeText ( this , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show () findViewById < View >( R . id . progress ). visibility = View . GONE } } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 public class AnimatedCardFieldActivity extends AppCompatActivity implements Observer < PaymentResponse > { private Context mContext = this ; AnimatedCardFieldFragment animatedCardFieldFragment ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_animated_card_form ); animatedCardFieldFragment = new AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . build (); getSupportFragmentManager () . beginTransaction () . add ( R . id . card_field_container , animatedCardFieldFragment ) . commit (); animatedCardFieldFragment . getEventObserver () . subscribe ( state -> { Log . i ( \"event\" , state . toString ()); } ); } public void onSubmitButtonClicked ( View view ) { if ( animatedCardFieldFragment . getCardBundle () != null ) { new Client ( this , URL_EE_TEST , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( animatedCardFieldFragment . getCardBundle ())); findViewById ( R . id . progress ). setVisibility ( View . VISIBLE ); } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show (); } } public CardFieldPayment getCardFormPayment ( CardBundle cardBundle ) { String timestamp = SignatureHelper . generateTimestamp (); String merchantID = \"33f6d473-3036-4ca5-acb5-8c64dac862d1\" ; String secretKey = \"9e0130f6-2e1e-4185-b0d5-dc69079c75cc\" ; String requestID = UUID . randomUUID (). toString (); TransactionType transactionType = TransactionType . PURCHASE ; BigDecimal amount = new BigDecimal ( 5 ); String currency = \"EUR\" ; String signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . getValue (), amount , currency , secretKey ); CardFieldPayment cardFieldPayment = new CardFieldPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build (); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); cardFieldPayment . setAccountHolder ( accountHolder ); return cardFieldPayment ; } @Override public void onObserve ( PaymentResponse paymentResponse ) { runOnUiThread (() -> { Toast . makeText ( this , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show (); findViewById ( R . id . progress ). setVisibility ( View . GONE ); } ); } } Additional Options for Animated Card Field \u00b6 You can set additional options for Animated Card Field through AnimatedCardFieldFragment.Builder : SetSupportedCardBrands - sets allowed card brands (providers) setExpirationDate - used in token payments setRequestFocus - sets screen focus (after the card form loads) setHideCardHolder - Sets whether card holder field is required and should be displayed setToken - used in token payments setMaskedCardNumber - used in token payments setCardBrand - sets the card brand/provider setTextSize - changes text size setLocale - changes the payment locale setNativeLocale - changes the payment locale (UI only) setRequireManualCardBrandSelection - Sets whether show card brand picker Token Payment with Animated Card Field \u00b6 The payment object is identical to a normal card field payment (like the example above), but you need to include the card token. Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 ... animatedCardFieldFragment = AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . setToken ( \"4304509873471003\" ) . setCardBrand ( CardBrand . VISA ) . build () ... val cardToken = CardToken () cardToken . tokenId = \"4304509873471003\" cardFieldPayment . cardToken = cardToken ... Java 1 2 3 4 5 6 7 8 9 10 11 12 ... animatedCardFieldFragment = new AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . setToken ( \"4304509873471003\" ) . setCardBrand ( CardBrand . VISA ) . build (); ... CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"4304509873471003\" ); cardFieldPayment . setCardToken ( cardToken ); ... Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 Changing Text Size \u00b6 To change the text size for cardField fragments use the dimension attribute wd_ecom_cardfield_text_size . To change text size in any other modules use the dimension attribute wd_ecom_text_size . Customizing Simple Card Payments \u00b6 Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_camera_blue 11 - wd_ecom_date 12 - wd_ecom_lock Customizing Animated Card Payments \u00b6 The same applies for Animated Card Field payments. Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_toolbar_text 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_main_alpha80 6 - wd_ecom_color_main_alpha40 7 - wd_ecom_color_error 8 - wd_ecom_color_main_background Icons 9 - wd_ecom_arrow_back 10 - wd_ecom_chip Customizing cardField Fragments \u00b6 Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_error Card Brand Picker \u00b6 To show card brand picker UI component over card number input field for Card Field, set setRequireManualCardBrandSelection through it's Builder class to true. For basic Card Payment, set CardPayment 's property requireManualCardBrandSelection to true.","title":"Card Payments"},{"location":"Card_Payments/#card-payments","text":"","title":"Card Payments"},{"location":"Card_Payments/#supported-transaction-types","text":"This payment method supports the following transaction types: purchase - charges the account holder's card and immediately transfers the reserved amount. authorization-only - verifies the validity of account holder's card, but does not leave an authorized amount. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. referenced-purchase - charges the account holder's card and immediately transfers the reserved amount. References a previous purchase transaction. referenced-authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. References a previous authorization transaction. capture-authorization - captures a previously authorized amount from the account holder's card. Must refer to an existing authorization transaction. tokenize - provides a unique token which represents the tokenized card data. This token then can be used in future transactions. enrollment - provides card enrollment with loyalty card support. Loyalty card data must be provided. This transaction type must be done without requested amount/currency","title":"Supported Transaction Types"},{"location":"Card_Payments/#supported-card-brands","text":"As of version 4.2.0 the Card Brand CUP has been deprecated and got replaced by UPI. Make sure to switch to new card type and do not use UPI a CUP together (this will throw PaymentException).","title":"Supported Card Brands"},{"location":"Card_Payments/#default-card-brands","text":"Card brand CB is supported but disabled by default, please add manually using dedicated method (setSupportedCardBrands()) to enable CB card brand.","title":"Default Card Brands"},{"location":"Card_Payments/#signature","text":"Application shall get signature from server where signature shall be computed.","title":"Signature"},{"location":"Card_Payments/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation ( \"com.wirecard.ecom:card:4.2.0\" ) { // uncomment exclude module in case you would like to disable card scanning feature // exclude module: 'play-services-vision' } ... } To disable the card scanner feature, uncomment the exclude module line. When adding/removing this feature, perform a full clean build. If you intend to use Card Payments module together with the SEPA Direct Debit module (with enabled IBAN scanner), you must enable it in both modules.","title":"Module Dependency"},{"location":"Card_Payments/#basic-card-payment","text":"This is a code example for a basic card payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , amount , currency ) // for enabling animated card layout cardPayment . animatedCardPayment = true // force 3D Secure attempt cardPayment . attempt3d = true Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . build (); // for enabling animated card layout cardPayment . setAnimatedCardPayment ( true ); // force 3D Secure attempt cardPayment . setAttempt3d ( true ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ); Note: You can set additional parameters after the payment object is created. Check the API documentation for more details.","title":"Basic Card Payment"},{"location":"Card_Payments/#token-payment","text":"This is a code example for a card payment which uses a card token (obtained from a previous transaction): Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , amount , currency ) // for enabling animated card layout cardPayment . animatedCardPayment = true val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken cardToken . tokenUsageIndicator = true cardToken . requireSecurityCode = true Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . build (); // for enabling animated card layout cardPayment . setAnimatedCardPayment ( true ); CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . setCardToken ( cardToken ); cardPayment . setRequireSecurityCode ( true ); cardPayment . setTokenUsageIndicator ( true ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment );","title":"Token payment"},{"location":"Card_Payments/#card-enrollment","text":"This transaction must be done without providing amount/currency within the request body. Mandatory field in the request is one of following: - accountHolder.email - This is the end-consumer\u2019s email-address. - accountHolder.phone - This is the phone number of the end-consumer. - consumerId - This is the end-consumer's identifier. The consumerId is mandatory for Enroll Card With Token This is a code example for a card enrollment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // be sure to NOT provide amount and currency val cardPayment = CardPayment ( signature , requestID , merchantID , transactionType , null , null ) // for providing mandatory field val customerData = AccountHolder () customerData . lastName = \"Doe\" customerData . email = \"john.doe@gmail.com\" // and/or customerData . phone = \"+421905555555\" cardPayment . accountHolder = customerData // or providing consumerId instead of AccountHolder's fields cardPayment . consumerId = \"1234567\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // be sure to NOT provide amount and currency CardPayment cardPayment = new CardPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . build (); // for providing mandatory field AccountHolder customerData = AccountHolder (); customerData . setLastName ( \"Doe\" ); customerData . setEmail ( \"john.doe@gmail.com\" ); // and/or customerData . setPhone ( \"+421905555555\" ); cardPayment . setAccountHolder ( customerData ); // or providing consumerId instead of AccountHolder's fields cardPayment . setConsumerId ( \"1234567\" ); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ); Note: For token based enrollment refer to Token payment. As mentioned above the consumerId is mandatory and must be provided within the CardPayment object. Adding card can be done using LoyaltyCard.userId property in the CardPayment object.","title":"Card enrollment"},{"location":"Card_Payments/#card-field","text":"Card Field is a feature where card information (card number, expiration date and CVV) is entered into a single, dynamically changing field instead of multiple separate ones. Here's example code for a card payment using this feature: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class KotlinCardFieldActivity : AppCompatActivity (), Observer < PaymentResponse > { private val mContext = this private val mPaymentObjectProvider = PaymentObjectProvider () private lateinit var cardFieldFragment : CardFieldFragment override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_card_form ) cardFieldFragment = CardFieldFragment . Builder (). build () supportFragmentManager . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit () cardFieldFragment . getEventObserver () . subscribe { state -> Log . i ( \"event\" , state . toString ()) } } fun onSubmitButtonClicked ( view : View ) { if ( cardFieldFragment . getCardBundle () != null ) { Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())) findViewById < View >( R . id . progress ). visibility = View . VISIBLE } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show () } } fun getCardFormPayment ( cardBundle : CardBundle ): CardFormPayment { val merchantID = \"merchant_id\" val secretKey = \"secret_key\" val requestID = UUID . randomUUID (). toString () val transactionType = TransactionType . PURCHASE val amount = BigDecimal ( 5 ) val currency = \"EUR\" val signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . value , amount , currency , secretKey ) val cardFormPayment = CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build () val accountHolder = AccountHolder ( \"John\" , \"Doe\" ) cardFormPayment . accountHolder = accountHolder return cardFormPayment } override fun onObserve ( paymentResponse : PaymentResponse ) { runOnUiThread { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show () findViewById < View >( R . id . progress ). visibility = View . GONE } } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class CardFieldActivity extends AppCompatActivity implements Observer < PaymentResponse > { private Context mContext = this ; private PaymentObjectProvider mPaymentObjectProvider = new PaymentObjectProvider (); CardFieldFragment cardFieldFragment ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_card_form ); cardFieldFragment = new CardFieldFragment . Builder (). build (); getSupportFragmentManager () . beginTransaction () . add ( R . id . card_field_container , cardFieldFragment ) . commit (); cardFieldFragment . getEventObserver () . subscribe ( state -> { Log . i ( \"event\" , state . toString ()); } ); } public void onSubmitButtonClicked ( View view ) { if ( cardFieldFragment . getCardBundle () != null ) { new Client ( this , URL_EE_TEST , null , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( cardFieldFragment . getCardBundle ())); findViewById ( R . id . progress ). setVisibility ( View . VISIBLE ); } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show (); } } public CardFormPayment getCardFormPayment ( CardBundle cardBundle ) { String merchantID = \"merchant_id\" ; String secretKey = \"secret_key\" ; String requestID = UUID . randomUUID (). toString (); TransactionType transactionType = TransactionType . PURCHASE ; BigDecimal amount = new BigDecimal ( 5 ); String currency = \"EUR\" ; String signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . getValue (), amount , currency , secretKey ); CardFormPayment cardFormPayment = new CardFormPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build (); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); cardFormPayment . setAccountHolder ( accountHolder ); return cardFormPayment ; } @Override public void onObserve ( PaymentResponse paymentResponse ) { runOnUiThread (() -> { Toast . makeText ( mContext , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show (); findViewById ( R . id . progress ). setVisibility ( View . GONE ); } ); } } Client can be initialized with android.support.v4.app.Fragment instance as well. The response is being handled similar as example above by implementing Observer in your android.support.v4.app.Fragment class. For more information and example refer to CardFieldFragmentImplFragment implementation in example application.","title":"Card Field"},{"location":"Card_Payments/#additional-options-for-card-field","text":"You can set additional options for Card Field through CardFieldFragment.Builder : SetSupportedCardBrands - sets allowed card brands (providers) setExpirationDate - used in token payments setRequestFocus - sets screen focus (after the card form loads) setHideCardIcon - hides provider icons (VISA, Maestro, etc.) setToken - used in token payments setMaskedCardNumber - used in token payments setCardBrand - sets the card brand/provider setTextSize - changes text size setLocale - changes the payment locale setNativeLocale - changes the payment locale (UI only)","title":"Additional Options for Card Field"},{"location":"Card_Payments/#token-payment-with-card-field","text":"The payment object is identical to a normal card field payment (like the example above), but you need to include the card token. Kotlin 1 2 3 4 5 6 7 8 ... val cardToken = CardToken () cardToken . tokenId = \"12345678901111\" cardPayment . cardToken = cardToken ... cardFieldBuilder . setToken ( cardToken . tokenId ) cardFieldBuilder . setCardBrand ( CardBrand . VISA ) ... Java 1 2 3 4 5 6 7 8 ... CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"12345678901111\" ); cardPayment . cardToken = cardToken ; ... cardPayment . setCardToken ( cardToken ); cardFieldBuilder . setCardBrand ( CardBrand . VISA ); ...","title":"Token Payment with Card Field"},{"location":"Card_Payments/#animated-card-field","text":"Animated Card Field is a feature where card information (card number, expiration date and CVV) is entered into a single, dynamically changing field with animated representation of the card. Here's example code for a card payment using this feature: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class KotlinAnimatedCardFieldActivity : AppCompatActivity (), Observer < PaymentResponse > { private val mContext = this private lateinit var animatedCardFieldFragment : AnimatedCardFieldFragment override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_animated_card_form ) animatedCardFieldFragment = AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . build () supportFragmentManager . beginTransaction () . add ( R . id . card_field_container , animatedCardFieldFragment ) . commit () animatedCardFieldFragment . getEventObserver () . subscribe { state -> Log . i ( \"event\" , state . toString ()) } } fun onSubmitButtonClicked ( view : View ) { if ( animatedCardFieldFragment . getCardBundle () != null ) { Client ( this , URL_EE_TEST , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( animatedCardFieldFragment . getCardBundle ())) findViewById < View >( R . id . progress ). visibility = View . VISIBLE } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show () } } fun getCardFormPayment ( cardBundle : CardBundle ?): CardFieldPayment { val timestamp = SignatureHelper . generateTimestamp () val merchantID = \"33f6d473-3036-4ca5-acb5-8c64dac862d1\" val secretKey = \"9e0130f6-2e1e-4185-b0d5-dc69079c75cc\" val requestID = UUID . randomUUID (). toString () val transactionType = TransactionType . PURCHASE val amount = BigDecimal ( 5 ) val currency = \"EUR\" val signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . value , amount , currency , secretKey ) val cardFieldPayment = CardFieldPayment . Builder () . setSignature ( signature !! ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle !! ) . build () val accountHolder = AccountHolder ( \"John\" , \"Doe\" ) cardFieldPayment . accountHolder = accountHolder return cardFieldPayment } override fun onObserve ( paymentResponse : PaymentResponse ) { runOnUiThread { Toast . makeText ( this , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show () findViewById < View >( R . id . progress ). visibility = View . GONE } } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 public class AnimatedCardFieldActivity extends AppCompatActivity implements Observer < PaymentResponse > { private Context mContext = this ; AnimatedCardFieldFragment animatedCardFieldFragment ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_animated_card_form ); animatedCardFieldFragment = new AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . build (); getSupportFragmentManager () . beginTransaction () . add ( R . id . card_field_container , animatedCardFieldFragment ) . commit (); animatedCardFieldFragment . getEventObserver () . subscribe ( state -> { Log . i ( \"event\" , state . toString ()); } ); } public void onSubmitButtonClicked ( View view ) { if ( animatedCardFieldFragment . getCardBundle () != null ) { new Client ( this , URL_EE_TEST , REQUEST_TIMEOUT ). startPayment ( getCardFormPayment ( animatedCardFieldFragment . getCardBundle ())); findViewById ( R . id . progress ). setVisibility ( View . VISIBLE ); } else { Toast . makeText ( mContext , \"Card bundle is null!\" , Toast . LENGTH_SHORT ). show (); } } public CardFieldPayment getCardFormPayment ( CardBundle cardBundle ) { String timestamp = SignatureHelper . generateTimestamp (); String merchantID = \"33f6d473-3036-4ca5-acb5-8c64dac862d1\" ; String secretKey = \"9e0130f6-2e1e-4185-b0d5-dc69079c75cc\" ; String requestID = UUID . randomUUID (). toString (); TransactionType transactionType = TransactionType . PURCHASE ; BigDecimal amount = new BigDecimal ( 5 ); String currency = \"EUR\" ; String signature = SignatureHelper . generateSignature ( timestamp , merchantID , requestID , transactionType . getValue (), amount , currency , secretKey ); CardFieldPayment cardFieldPayment = new CardFieldPayment . Builder () . setSignature ( signature ) . setMerchantAccountId ( merchantID ) . setRequestId ( requestID ) . setAmount ( amount ) . setTransactionType ( transactionType ) . setCurrency ( currency ) . setCardBundle ( cardBundle ) . build (); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); cardFieldPayment . setAccountHolder ( accountHolder ); return cardFieldPayment ; } @Override public void onObserve ( PaymentResponse paymentResponse ) { runOnUiThread (() -> { Toast . makeText ( this , ResponseHelper . getFormattedResponse ( paymentResponse ), Toast . LENGTH_SHORT ). show (); findViewById ( R . id . progress ). setVisibility ( View . GONE ); } ); } }","title":"Animated Card Field"},{"location":"Card_Payments/#additional-options-for-animated-card-field","text":"You can set additional options for Animated Card Field through AnimatedCardFieldFragment.Builder : SetSupportedCardBrands - sets allowed card brands (providers) setExpirationDate - used in token payments setRequestFocus - sets screen focus (after the card form loads) setHideCardHolder - Sets whether card holder field is required and should be displayed setToken - used in token payments setMaskedCardNumber - used in token payments setCardBrand - sets the card brand/provider setTextSize - changes text size setLocale - changes the payment locale setNativeLocale - changes the payment locale (UI only) setRequireManualCardBrandSelection - Sets whether show card brand picker","title":"Additional Options for Animated Card Field"},{"location":"Card_Payments/#token-payment-with-animated-card-field","text":"The payment object is identical to a normal card field payment (like the example above), but you need to include the card token. Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 ... animatedCardFieldFragment = AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . setToken ( \"4304509873471003\" ) . setCardBrand ( CardBrand . VISA ) . build () ... val cardToken = CardToken () cardToken . tokenId = \"4304509873471003\" cardFieldPayment . cardToken = cardToken ... Java 1 2 3 4 5 6 7 8 9 10 11 12 ... animatedCardFieldFragment = new AnimatedCardFieldFragment . Builder () . setRequestFocus ( true ) . setRequireManualCardBrandSelection ( true ) . setToken ( \"4304509873471003\" ) . setCardBrand ( CardBrand . VISA ) . build (); ... CardToken cardToken = new CardToken (); cardToken . setTokenId ( \"4304509873471003\" ); cardFieldPayment . setCardToken ( cardToken ); ...","title":"Token Payment with Animated Card Field"},{"location":"Card_Payments/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"Card_Payments/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"Card_Payments/#changing-fonts","text":"To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1","title":"Changing Fonts"},{"location":"Card_Payments/#changing-text-size","text":"To change the text size for cardField fragments use the dimension attribute wd_ecom_cardfield_text_size . To change text size in any other modules use the dimension attribute wd_ecom_text_size .","title":"Changing Text Size"},{"location":"Card_Payments/#customizing-simple-card-payments","text":"Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_camera_blue 11 - wd_ecom_date 12 - wd_ecom_lock","title":"Customizing Simple Card Payments"},{"location":"Card_Payments/#customizing-animated-card-payments","text":"The same applies for Animated Card Field payments. Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_toolbar_text 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_main_alpha80 6 - wd_ecom_color_main_alpha40 7 - wd_ecom_color_error 8 - wd_ecom_color_main_background Icons 9 - wd_ecom_arrow_back 10 - wd_ecom_chip","title":"Customizing Animated Card Payments"},{"location":"Card_Payments/#customizing-cardfield-fragments","text":"Color resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_error","title":"Customizing cardField Fragments"},{"location":"Card_Payments/#card-brand-picker","text":"To show card brand picker UI component over card number input field for Card Field, set setRequireManualCardBrandSelection through it's Builder class to true. For basic Card Payment, set CardPayment 's property requireManualCardBrandSelection to true.","title":"Card Brand Picker"},{"location":"Google_Pay/","text":"Google Pay \u00b6 There are two payment flows with Google Pay: - a simple payment which automatically creates the Google Pay UI and passes information to Wirecard Payment Processing Gateway when the payment is successful, - your own customized UI and workflow, in which case you have to create it from scratch and pass the Google Pay payment information to paymentSDK (which then silently processes the payment). Supported Transaction Types \u00b6 purchase - charges the account holder's card and immediately transfers the reserved amount. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:google-pay:4.2.0\" ... } Signature \u00b6 Application shall get signature from server where signature shall be computed. Simple flow (SDK managed) \u00b6 This is a code example for a basic Google Pay payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // card brands constraint val cardBrands = ArrayList () cardBrands . add ( CardBrand . VISA ) val googlePayPayment = GooglePayPayment . Builder () // Google Pay related . setShippingAddressRequired ( true ) . setBillingAddressRequired ( true ) . setEmailAddressRequired ( true ) . setPhoneNumberRequired ( true ) . setGooglePayUiTheme ( true ) . setSupportedCardBrands ( cardBrands ) // EE Related . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( getTransactionType ( paymentState . getTransactionType ())) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . build () // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . environment = WalletConstants . ENVIRONMENT_TEST Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // card brands constraint List < CardBrand > cardBrands = new ArrayList <>(); cardBrands . add ( CardBrand . VISA ); GooglePayPayment googlePayPayment = new GooglePayPayment . Builder () // Google Pay related . setShippingAddressRequired ( true ) . setBillingAddressRequired ( true ) . setEmailAddressRequired ( true ) . setPhoneNumberRequired ( true ) . setGooglePayUiTheme ( true ) . setSupportedCardBrands ( cardBrands ) // EE Related . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( getTransactionType ( paymentState . getTransactionType ())) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . build (); // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ); new Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ); Note : Google Pay environment is set to ENVIRONMENT_TEST by default in order to prevent real payments. Make sure to change it to ENVIRONMENT_PRODUCTION before going live. paymentData property is set to null as this is produced by Google Pay itself. Merchant managed flow (created by you) \u00b6 If you want to handle the Google Pay UI and flow on your own, there is an option to use paymentSDK just for communicating the transaction result from Google Pay to the Wirecard Payment Processing Gateway: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class GooglePayPaymentActivity : AppCompatActivity () { private val LOAD_PAYMENT_DATA_REQUEST_CODE = 992 private lateinit var paymentClient : PaymentsClient override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_google_pay ) //android O fix bug orientation if ( android . os . Build . VERSION . SDK_INT < Build . VERSION_CODES . O ) { requestedOrientation = ActivityInfo . SCREEN_ORIENTATION_PORTRAIT } val supportedCardBrands = Arrays . asList ( CARD_NETWORK_VISA ) paymentClient = Wallet . getPaymentsClient ( this , Wallet . WalletOptions . Builder () . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ) . build ()) val transactionInfo = Transaction ( \"1,00\" , \"EUR\" ). getTransactionInfo () val paramsBuilder = PaymentMethodTokenizationParameters . newBuilder () . setPaymentMethodTokenizationType ( WalletConstants . PAYMENT_METHOD_TOKENIZATION_TYPE_PAYMENT_GATEWAY ) . addParameter ( \"gateway\" , \"wirecard\" ) . addParameter ( \"gatewayMerchantId\" , \"your_merchant_account_id\" ) val paymentDataRequest = PaymentDataRequest . newBuilder () . setPhoneNumberRequired ( true ) . setEmailRequired ( true ) . setShippingAddressRequired ( true ) . addAllowedPaymentMethods ( Arrays . asList ( WalletConstants . PAYMENT_METHOD_CARD , WalletConstants . PAYMENT_METHOD_TOKENIZED_CARD )) . setCardRequirements ( CardRequirements . newBuilder () . addAllowedCardNetworks ( supportedCardBrands ) . setAllowPrepaidCards ( true ) . setBillingAddressRequired ( true ) . build () ) . setTransactionInfo ( transactionInfo ) . setPaymentMethodTokenizationParameters ( paramsBuilder . build ()) . setUiRequired ( true ) . build () val futurePaymentData : Task < PaymentData > = paymentClient . loadPaymentData ( paymentDataRequest ) AutoResolveHelper . resolveTask ( futurePaymentData , this @GooglePayPaymentActivity , LOAD_PAYMENT_DATA_REQUEST_CODE ) } override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val intent = Intent () if ( LOAD_PAYMENT_DATA_REQUEST_CODE != requestCode ) return when ( resultCode ) { Activity . RESULT_OK -> { val paymentData = PaymentData . getFromIntent ( data !! ) // } Activity . RESULT_CANCELED -> { // handle user canceled the payment process } AutoResolveHelper . RESULT_ERROR -> { // something went wrong - handle here } } val paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { // handle response from Elastic Engine } } private fun startPayment ( paymentData : PaymentData ) { val googlePayPayment = GooglePayPayment . Builder () . setPaymentData ( paymentData ) . setSignature ( \"signature v2\" ) . setRequestTimeStamp ( \"timestamp\" ) . setRequestId ( \"request id\" ) . setMerchantAccountId ( \"merchant account id\" ) . setTransactionType ( TransactionType . PURCHASE ) . setAmount ( BugDecimal ( 1.00 )) . setCurrency ( \"EUR\" ) . build () // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . environment = WalletConstants . ENVIRONMENT_TEST Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ) } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class GooglePayPaymentActivity extends AppCompatActivity { private final int LOAD_PAYMENT_DATA_REQUEST_CODE = 992 ; private PaymentsClient paymentClient ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_google_pay ); //android O fix bug orientation if ( android . os . Build . VERSION . SDK_INT < Build . VERSION_CODES . O ) { setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ); } List < Integer > supportedCardBrands = new ArrayList <>(); supportedCardBrands . add ( WalletConstants . CARD_NETWORK_VISA ); paymentClient = Wallet . getPaymentsClient ( this , new Wallet . WalletOptions . Builder () . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ) . build ()); TransactionInfo transactionInfo = new Transaction ( \"1,00\" , \"EUR\" ). getTransactionInfo (); PaymentMethodTokenizationParameters . Builder paramsBuilder = PaymentMethodTokenizationParameters . newBuilder () . setPaymentMethodTokenizationType ( WalletConstants . PAYMENT_METHOD_TOKENIZATION_TYPE_PAYMENT_GATEWAY ) . addParameter ( \"gateway\" , \"wirecard\" ) . addParameter ( \"gatewayMerchantId\" , \"your_merchant_account_id\" ); PaymentDataRequest paymentDataRequest = PaymentDataRequest . newBuilder () . setPhoneNumberRequired ( true ) . setEmailRequired ( true ) . setShippingAddressRequired ( true ) . addAllowedPaymentMethods ( Arrays . asList ( WalletConstants . PAYMENT_METHOD_CARD , WalletConstants . PAYMENT_METHOD_TOKENIZED_CARD )) . setCardRequirements ( CardRequirements . newBuilder () . addAllowedCardNetworks ( supportedCardBrands ) . setAllowPrepaidCards ( true ) . setBillingAddressRequired ( true ) . build () ) . setTransactionInfo ( transactionInfo ) . setPaymentMethodTokenizationParameters ( paramsBuilder . build ()) . setUiRequired ( true ) . build (); Task < PaymentData > futurePaymentData = paymentClient . loadPaymentData ( paymentDataRequest ); AutoResolveHelper . resolveTask ( futurePaymentData , this , LOAD_PAYMENT_DATA_REQUEST_CODE ); } @Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Intent intent = new Intent (); if ( LOAD_PAYMENT_DATA_REQUEST_CODE != requestCode ) return ; switch ( resultCode ) { case Activity . RESULT_OK : { PaymentData paymentData = PaymentData . getFromIntent ( data ); startPayment ( paymentData ); break ; } case Activity . RESULT_CANCELED : { // handle user canceled the payment process break ; } case AutoResolveHelper . RESULT_ERROR : { // something went wrong - handle here break ; } } Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { // handle response from Elastic Engine } } private void startPayment ( PaymentData paymentData ) { GooglePayPayment googlePayPayment = new GooglePayPayment . Builder () // make sure the . setPaymentData ( paymentData ) . setSignature ( \"v2 signature\" ) . setRequestTimeStamp ( \"timestamp\" ) . setRequestId ( \"request id\" ) . setMerchantAccountId ( \"merchant account id\" ) . setTransactionType ( TransactionType . PURCHASE ) . setAmount ( new BigDecimal ( 1.00 )) . setCurrency ( \"EUR\" ) . build (); // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ); new Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ); } } Customization \u00b6 You can only work with Google Pay's proprietary UI itself. You can modify the basic behaviour by setting following values: setShippingAddressRequired(requireShippingAddress: Boolean) - whether shipping address is required setBillingAddressRequired(requireBillingAddress: Boolean) - whether billing address is required setEmailAddressRequired(requireEmailAddress: Boolean) - whether email address is required setPhoneNumberRequired(requirePhoneNumber: Boolean) - whether phone is required setGooglePayUiTheme(googlePayUiTheme: Int) - sets the theme for Google Pay UI setSupportedCardBrands(supportedCardBrands: MutableList<CardBrand>) - limits set of supported card brands This configuration is available only when using the SDK managed flow. Please refer to API documentation for more options.","title":"Google Pay"},{"location":"Google_Pay/#google-pay","text":"There are two payment flows with Google Pay: - a simple payment which automatically creates the Google Pay UI and passes information to Wirecard Payment Processing Gateway when the payment is successful, - your own customized UI and workflow, in which case you have to create it from scratch and pass the Google Pay payment information to paymentSDK (which then silently processes the payment).","title":"Google Pay"},{"location":"Google_Pay/#supported-transaction-types","text":"purchase - charges the account holder's card and immediately transfers the reserved amount. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction.","title":"Supported Transaction Types"},{"location":"Google_Pay/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:google-pay:4.2.0\" ... }","title":"Module Dependency"},{"location":"Google_Pay/#signature","text":"Application shall get signature from server where signature shall be computed.","title":"Signature"},{"location":"Google_Pay/#simple-flow-sdk-managed","text":"This is a code example for a basic Google Pay payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // card brands constraint val cardBrands = ArrayList () cardBrands . add ( CardBrand . VISA ) val googlePayPayment = GooglePayPayment . Builder () // Google Pay related . setShippingAddressRequired ( true ) . setBillingAddressRequired ( true ) . setEmailAddressRequired ( true ) . setPhoneNumberRequired ( true ) . setGooglePayUiTheme ( true ) . setSupportedCardBrands ( cardBrands ) // EE Related . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( getTransactionType ( paymentState . getTransactionType ())) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . build () // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . environment = WalletConstants . ENVIRONMENT_TEST Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // card brands constraint List < CardBrand > cardBrands = new ArrayList <>(); cardBrands . add ( CardBrand . VISA ); GooglePayPayment googlePayPayment = new GooglePayPayment . Builder () // Google Pay related . setShippingAddressRequired ( true ) . setBillingAddressRequired ( true ) . setEmailAddressRequired ( true ) . setPhoneNumberRequired ( true ) . setGooglePayUiTheme ( true ) . setSupportedCardBrands ( cardBrands ) // EE Related . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( getTransactionType ( paymentState . getTransactionType ())) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . build (); // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ); new Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ); Note : Google Pay environment is set to ENVIRONMENT_TEST by default in order to prevent real payments. Make sure to change it to ENVIRONMENT_PRODUCTION before going live. paymentData property is set to null as this is produced by Google Pay itself.","title":"Simple flow (SDK managed)"},{"location":"Google_Pay/#merchant-managed-flow-created-by-you","text":"If you want to handle the Google Pay UI and flow on your own, there is an option to use paymentSDK just for communicating the transaction result from Google Pay to the Wirecard Payment Processing Gateway: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class GooglePayPaymentActivity : AppCompatActivity () { private val LOAD_PAYMENT_DATA_REQUEST_CODE = 992 private lateinit var paymentClient : PaymentsClient override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) setContentView ( R . layout . activity_google_pay ) //android O fix bug orientation if ( android . os . Build . VERSION . SDK_INT < Build . VERSION_CODES . O ) { requestedOrientation = ActivityInfo . SCREEN_ORIENTATION_PORTRAIT } val supportedCardBrands = Arrays . asList ( CARD_NETWORK_VISA ) paymentClient = Wallet . getPaymentsClient ( this , Wallet . WalletOptions . Builder () . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ) . build ()) val transactionInfo = Transaction ( \"1,00\" , \"EUR\" ). getTransactionInfo () val paramsBuilder = PaymentMethodTokenizationParameters . newBuilder () . setPaymentMethodTokenizationType ( WalletConstants . PAYMENT_METHOD_TOKENIZATION_TYPE_PAYMENT_GATEWAY ) . addParameter ( \"gateway\" , \"wirecard\" ) . addParameter ( \"gatewayMerchantId\" , \"your_merchant_account_id\" ) val paymentDataRequest = PaymentDataRequest . newBuilder () . setPhoneNumberRequired ( true ) . setEmailRequired ( true ) . setShippingAddressRequired ( true ) . addAllowedPaymentMethods ( Arrays . asList ( WalletConstants . PAYMENT_METHOD_CARD , WalletConstants . PAYMENT_METHOD_TOKENIZED_CARD )) . setCardRequirements ( CardRequirements . newBuilder () . addAllowedCardNetworks ( supportedCardBrands ) . setAllowPrepaidCards ( true ) . setBillingAddressRequired ( true ) . build () ) . setTransactionInfo ( transactionInfo ) . setPaymentMethodTokenizationParameters ( paramsBuilder . build ()) . setUiRequired ( true ) . build () val futurePaymentData : Task < PaymentData > = paymentClient . loadPaymentData ( paymentDataRequest ) AutoResolveHelper . resolveTask ( futurePaymentData , this @GooglePayPaymentActivity , LOAD_PAYMENT_DATA_REQUEST_CODE ) } override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val intent = Intent () if ( LOAD_PAYMENT_DATA_REQUEST_CODE != requestCode ) return when ( resultCode ) { Activity . RESULT_OK -> { val paymentData = PaymentData . getFromIntent ( data !! ) // } Activity . RESULT_CANCELED -> { // handle user canceled the payment process } AutoResolveHelper . RESULT_ERROR -> { // something went wrong - handle here } } val paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { // handle response from Elastic Engine } } private fun startPayment ( paymentData : PaymentData ) { val googlePayPayment = GooglePayPayment . Builder () . setPaymentData ( paymentData ) . setSignature ( \"signature v2\" ) . setRequestTimeStamp ( \"timestamp\" ) . setRequestId ( \"request id\" ) . setMerchantAccountId ( \"merchant account id\" ) . setTransactionType ( TransactionType . PURCHASE ) . setAmount ( BugDecimal ( 1.00 )) . setCurrency ( \"EUR\" ) . build () // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . environment = WalletConstants . ENVIRONMENT_TEST Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ) } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class GooglePayPaymentActivity extends AppCompatActivity { private final int LOAD_PAYMENT_DATA_REQUEST_CODE = 992 ; private PaymentsClient paymentClient ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_google_pay ); //android O fix bug orientation if ( android . os . Build . VERSION . SDK_INT < Build . VERSION_CODES . O ) { setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ); } List < Integer > supportedCardBrands = new ArrayList <>(); supportedCardBrands . add ( WalletConstants . CARD_NETWORK_VISA ); paymentClient = Wallet . getPaymentsClient ( this , new Wallet . WalletOptions . Builder () . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ) . build ()); TransactionInfo transactionInfo = new Transaction ( \"1,00\" , \"EUR\" ). getTransactionInfo (); PaymentMethodTokenizationParameters . Builder paramsBuilder = PaymentMethodTokenizationParameters . newBuilder () . setPaymentMethodTokenizationType ( WalletConstants . PAYMENT_METHOD_TOKENIZATION_TYPE_PAYMENT_GATEWAY ) . addParameter ( \"gateway\" , \"wirecard\" ) . addParameter ( \"gatewayMerchantId\" , \"your_merchant_account_id\" ); PaymentDataRequest paymentDataRequest = PaymentDataRequest . newBuilder () . setPhoneNumberRequired ( true ) . setEmailRequired ( true ) . setShippingAddressRequired ( true ) . addAllowedPaymentMethods ( Arrays . asList ( WalletConstants . PAYMENT_METHOD_CARD , WalletConstants . PAYMENT_METHOD_TOKENIZED_CARD )) . setCardRequirements ( CardRequirements . newBuilder () . addAllowedCardNetworks ( supportedCardBrands ) . setAllowPrepaidCards ( true ) . setBillingAddressRequired ( true ) . build () ) . setTransactionInfo ( transactionInfo ) . setPaymentMethodTokenizationParameters ( paramsBuilder . build ()) . setUiRequired ( true ) . build (); Task < PaymentData > futurePaymentData = paymentClient . loadPaymentData ( paymentDataRequest ); AutoResolveHelper . resolveTask ( futurePaymentData , this , LOAD_PAYMENT_DATA_REQUEST_CODE ); } @Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Intent intent = new Intent (); if ( LOAD_PAYMENT_DATA_REQUEST_CODE != requestCode ) return ; switch ( resultCode ) { case Activity . RESULT_OK : { PaymentData paymentData = PaymentData . getFromIntent ( data ); startPayment ( paymentData ); break ; } case Activity . RESULT_CANCELED : { // handle user canceled the payment process break ; } case AutoResolveHelper . RESULT_ERROR : { // something went wrong - handle here break ; } } Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { // handle response from Elastic Engine } } private void startPayment ( PaymentData paymentData ) { GooglePayPayment googlePayPayment = new GooglePayPayment . Builder () // make sure the . setPaymentData ( paymentData ) . setSignature ( \"v2 signature\" ) . setRequestTimeStamp ( \"timestamp\" ) . setRequestId ( \"request id\" ) . setMerchantAccountId ( \"merchant account id\" ) . setTransactionType ( TransactionType . PURCHASE ) . setAmount ( new BigDecimal ( 1.00 )) . setCurrency ( \"EUR\" ) . build (); // by default set to ENVIRONMENT_TEST. Make sure setting this property to ENVIRONMENT_PRODUCTION before going live googlePayPayment . setEnvironment ( WalletConstants . ENVIRONMENT_TEST ); new Client ( this , \"https://api-test.wirecard.com\" ). startPayment ( googlePayPayment ); } }","title":"Merchant managed flow (created by you)"},{"location":"Google_Pay/#customization","text":"You can only work with Google Pay's proprietary UI itself. You can modify the basic behaviour by setting following values: setShippingAddressRequired(requireShippingAddress: Boolean) - whether shipping address is required setBillingAddressRequired(requireBillingAddress: Boolean) - whether billing address is required setEmailAddressRequired(requireEmailAddress: Boolean) - whether email address is required setPhoneNumberRequired(requirePhoneNumber: Boolean) - whether phone is required setGooglePayUiTheme(googlePayUiTheme: Int) - sets the theme for Google Pay UI setSupportedCardBrands(supportedCardBrands: MutableList<CardBrand>) - limits set of supported card brands This configuration is available only when using the SDK managed flow. Please refer to API documentation for more options.","title":"Customization"},{"location":"License/","text":"License \u00b6 paymentSDK - MIT License \u00b6 Copyright , Wirecard AG Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 3\u02b3\u1d48 party licenses \u00b6 Retrofit2, OkHttp - Apache License 2.0 iban4j - Apache License 2.0 RxJava - Apache License 2.0 Zapp - Apache License 2.0","title":"License"},{"location":"License/#license","text":"","title":"License"},{"location":"License/#paymentsdk-mit-license","text":"Copyright , Wirecard AG Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"paymentSDK - MIT License"},{"location":"License/#3rd-party-licenses","text":"Retrofit2, OkHttp - Apache License 2.0 iban4j - Apache License 2.0 RxJava - Apache License 2.0 Zapp - Apache License 2.0","title":"3\u02b3\u1d48 party licenses"},{"location":"Localization/","text":"Localization \u00b6 You can set two types of locale - locale and localeUIOnly - in 3 combinations: locale is set - selected locale is sent to the backend and the UI is set to specified language, localeUIOnly is set - locale is not sent to backend, but UI is set to specified language, Both locale and localeUIOnly are set - the locale string is sent to backend and the UI is set according to localeUIOnly . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . locale = \"DE\" cardPayment . localeUIOnly = \"RU\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) This example shows the 3rd option (dual setting): the backend locale is set to DE and the frontend localeUIOnly to RU. This means that although the backend locale backend is DE, the UI language is RU. Override strings \u00b6 All strings are saved in the strings.xml file for all supported languages. In it you can find every possible language key. Important: Do not delete any special characters (e.g. {0}) to avoid errors.","title":"Localization"},{"location":"Localization/#localization","text":"You can set two types of locale - locale and localeUIOnly - in 3 combinations: locale is set - selected locale is sent to the backend and the UI is set to specified language, localeUIOnly is set - locale is not sent to backend, but UI is set to specified language, Both locale and localeUIOnly are set - the locale string is sent to backend and the UI is set according to localeUIOnly . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . locale = \"DE\" cardPayment . localeUIOnly = \"RU\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) This example shows the 3rd option (dual setting): the backend locale is set to DE and the frontend localeUIOnly to RU. This means that although the backend locale backend is DE, the UI language is RU.","title":"Localization"},{"location":"Localization/#override-strings","text":"All strings are saved in the strings.xml file for all supported languages. In it you can find every possible language key. Important: Do not delete any special characters (e.g. {0}) to avoid errors.","title":"Override strings"},{"location":"Migration/","text":"Migration from 2.x.x \u00b6 Repository Location \u00b6 The repository location has changed from JitPack to Bintray: 1 2 3 4 5 // 2.x.x repository url maven { url \"https://jitpack.io\" } // 3.x.x repository url maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } Make sure to change the package name and version: 1 2 3 4 5 // 2.x.x compile 'com.github.wirecard:paymentSDK-Android:2.15.0-cardScannerDisabled' // 3.x.x implementation \"com.wirecard.ecom:card:4.2.0\" Client Initialization \u00b6 The WirecardClient class is now Client and it's initialized by creating the object and passing arguments as Context, payment gateway URL address and request timeout. 1 2 3 4 5 6 7 // 2.x.x WirecardClient wirecardClient = WirecardClientBuilder.newInstance(this, environment) .setRequestTimeout(60) .build(); // 3.x.x Client client = new Client(mContext, URL_EE_TEST, REQUEST_TIMEOUT); Creating Payments \u00b6 The makePayment method is now startPayment and takes only one argument from the Payment object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 2.x.x wirecardClient.makePayment(wirecardPayment, null, new WirecardResponseListener() { @Override public void onResponse(WirecardPaymentResponse wirecardPaymentResponse) { // handle success } @Override public void onError(WirecardResponseError wirecardResponseError) { // handle error } }); // 3.x.x client.startPayment(cardPayment); Handling Transaction Responses (Results) \u00b6 Previously, the response listener object was one of the arguments for the makePayment method. This has changed and now you receive any response as an activity result: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 2.x.x new WirecardResponseListener() { @Override public void onResponse(WirecardPaymentResponse wirecardPaymentResponse) { // handle success } @Override public void onError(WirecardResponseError wirecardResponseError) { // handle error } } // 3.x.x @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); Serializable paymentSdkResponse = data.getSerializableExtra(Client.EXTRA_PAYMENT_SDK_RESPONSE); if (paymentSdkResponse instanceof PaymentResponse) { // handle result } } Migrating a CardField Integration \u00b6 Previously, the response was handled by an instance of WirecardInputFormsStateManager and WirecardInputFormsStateChangedListener . This implementation has been simplified: the response for any payment action of a CardField payment is now served as a parameter of the onObserve method. Your activity needs to implement the Observer<PaymentResponse> interface. Additionally, handling UI changes for CardField is changed from WirecardInputFormsStateChangedListener to subscribing to EventObserver . Theming and Customization \u00b6 2.x.x versions used PaymentPageStyleClass in order to define custom texts and other customizations. 3.x.x versions(latest) use the approach of overriding strings, colors, dimensions and drawables to change the default styling. For more information, consult the Theming section of a particular payment method. Notifications \u00b6 Till version 3.3.2 the notifications in the Payment object was list of Notification objects. 1 2 3 4 5 6 // < 3.3.2 Notification notification = new Notification(); notification3.setUrl(\"api-test.wirecard.com/engine/mobile/v2/notify\"); ArrayList<Notification> notifications = new ArrayList<>(); notifications.add(notification); payment.setNotifications(notifications); Current implementation added Notifications class for wrapping up all notifications and allows to set up notification format. 1 2 3 4 5 6 // from 3.4.0 Notification notification = new Notification(); notification3.setUrl(\"api-test.wirecard.com/engine/mobile/v2/notify\"); ArrayList<Notification> notifications = new ArrayList<>(); notifications.add(notification); payment.setNotifications(new Notifications(notifications, Notifications.FORMAT_JSON)); There are some predefined constants for notification format. For more information follow Notifications class in the Api documentation.","title":"Migration from 2.x.x"},{"location":"Migration/#migration-from-2xx","text":"","title":"Migration from 2.x.x"},{"location":"Migration/#repository-location","text":"The repository location has changed from JitPack to Bintray: 1 2 3 4 5 // 2.x.x repository url maven { url \"https://jitpack.io\" } // 3.x.x repository url maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } Make sure to change the package name and version: 1 2 3 4 5 // 2.x.x compile 'com.github.wirecard:paymentSDK-Android:2.15.0-cardScannerDisabled' // 3.x.x implementation \"com.wirecard.ecom:card:4.2.0\"","title":"Repository Location"},{"location":"Migration/#client-initialization","text":"The WirecardClient class is now Client and it's initialized by creating the object and passing arguments as Context, payment gateway URL address and request timeout. 1 2 3 4 5 6 7 // 2.x.x WirecardClient wirecardClient = WirecardClientBuilder.newInstance(this, environment) .setRequestTimeout(60) .build(); // 3.x.x Client client = new Client(mContext, URL_EE_TEST, REQUEST_TIMEOUT);","title":"Client Initialization"},{"location":"Migration/#creating-payments","text":"The makePayment method is now startPayment and takes only one argument from the Payment object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 2.x.x wirecardClient.makePayment(wirecardPayment, null, new WirecardResponseListener() { @Override public void onResponse(WirecardPaymentResponse wirecardPaymentResponse) { // handle success } @Override public void onError(WirecardResponseError wirecardResponseError) { // handle error } }); // 3.x.x client.startPayment(cardPayment);","title":"Creating Payments"},{"location":"Migration/#handling-transaction-responses-results","text":"Previously, the response listener object was one of the arguments for the makePayment method. This has changed and now you receive any response as an activity result: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 2.x.x new WirecardResponseListener() { @Override public void onResponse(WirecardPaymentResponse wirecardPaymentResponse) { // handle success } @Override public void onError(WirecardResponseError wirecardResponseError) { // handle error } } // 3.x.x @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); Serializable paymentSdkResponse = data.getSerializableExtra(Client.EXTRA_PAYMENT_SDK_RESPONSE); if (paymentSdkResponse instanceof PaymentResponse) { // handle result } }","title":"Handling Transaction Responses (Results)"},{"location":"Migration/#migrating-a-cardfield-integration","text":"Previously, the response was handled by an instance of WirecardInputFormsStateManager and WirecardInputFormsStateChangedListener . This implementation has been simplified: the response for any payment action of a CardField payment is now served as a parameter of the onObserve method. Your activity needs to implement the Observer<PaymentResponse> interface. Additionally, handling UI changes for CardField is changed from WirecardInputFormsStateChangedListener to subscribing to EventObserver .","title":"Migrating a CardField Integration"},{"location":"Migration/#theming-and-customization","text":"2.x.x versions used PaymentPageStyleClass in order to define custom texts and other customizations. 3.x.x versions(latest) use the approach of overriding strings, colors, dimensions and drawables to change the default styling. For more information, consult the Theming section of a particular payment method.","title":"Theming and Customization"},{"location":"Migration/#notifications","text":"Till version 3.3.2 the notifications in the Payment object was list of Notification objects. 1 2 3 4 5 6 // < 3.3.2 Notification notification = new Notification(); notification3.setUrl(\"api-test.wirecard.com/engine/mobile/v2/notify\"); ArrayList<Notification> notifications = new ArrayList<>(); notifications.add(notification); payment.setNotifications(notifications); Current implementation added Notifications class for wrapping up all notifications and allows to set up notification format. 1 2 3 4 5 6 // from 3.4.0 Notification notification = new Notification(); notification3.setUrl(\"api-test.wirecard.com/engine/mobile/v2/notify\"); ArrayList<Notification> notifications = new ArrayList<>(); notifications.add(notification); payment.setNotifications(new Notifications(notifications, Notifications.FORMAT_JSON)); There are some predefined constants for notification format. For more information follow Notifications class in the Api documentation.","title":"Notifications"},{"location":"OptionalData/","text":"Optional Data \u00b6 Following code snippet shows usage of frequently used optional data. Check out example application on GitHub as an demonstration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // account holder information Address address = new Address (); address . setStreet1 ( \"Einsteinring 35\" ); address . setCity ( \"Munich\" ); address . setPostalCode ( \"80331\" ); address . setCountry ( \"DE\" ); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); accountHolder . setDateOfBirth ( \"1986-01-01\" ); accountHolder . setAddress ( address ); cardPayment . setAccountHolder ( accountHolder ); // IP address cardPayment . setIpAddress ( \"127.0.0.1\" ); // loyalty card LoyaltyCard loyaltyCard = new LoyaltyCard (); loyaltyCard . setUserId ( \"7fe54e18-f251-4130-9f6b-0536afc86ee7\" ); loyaltyCard . setCardId ( \"32be4a4e-67ca-e911-b9b9-005056ab64a1\" ); cardPayment . setLoyaltyCard ( loyaltyCard ); // notifications Notification notification = new Notification (); notification . setUrl ( \"https://server.com\" ); List < Notification > listOfNotifications = new ArrayList <>(); listOfNotifications . add ( notification ); Notifications notifications = new Notifications (); notifications . setNotifications ( listOfNotifications ); notifications . setFormat ( Notifications . FORMAT_JSON ); cardPayment . setNotifications ( notifications ); // order OrderItem orderItem = new OrderItem (); orderItem . setName ( \"Bicycle\" ); orderItem . setDescription ( \"Best product ever\" ); orderItem . setArticleNumber ( \"BC1234\" ); orderItem . setAmount ( new RequestedAmount ( new BigDecimal ( 800 ), \"EUR\" )); orderItem . setQuantity ( 1 ); orderItem . setTaxRate ( new BigDecimal ( 20 )); ArrayList < OrderItem > orderItems = new ArrayList <>(); orderItems . add ( orderItem ); cardPayment . setOrderDetail ( \"Test product\" ); cardPayment . setOrderNumber ( \"DE11111111\" ); cardPayment . setOrderItems ( orderItems ); cardPayment . setOrderItems ( orderItems ); // shipping address Shipping shipping = new Shipping (); shipping . setShippingCity ( \"Berlin\" ); shipping . setShippingCountry ( \"DE\" ); shipping . setShippingPostalCode ( \"04001\" ); shipping . setShippingState ( \"Shipped\" ); shipping . setShippingStreet1 ( \"Street 1\" ); shipping . setShippingStreet2 ( \"Street 2 info\" ); shipping . setShippingStreet3 ( \"Street 3 info\" ); shipping . setShippingMethod ( ShippingMethod . SHIPPING_TO_STORE ); cardPayment . setShippingAddress ( shipping ); // descriptor cardPayment . setDescriptor ( \"Demo descriptor\" );","title":"Optional data"},{"location":"OptionalData/#optional-data","text":"Following code snippet shows usage of frequently used optional data. Check out example application on GitHub as an demonstration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // account holder information Address address = new Address (); address . setStreet1 ( \"Einsteinring 35\" ); address . setCity ( \"Munich\" ); address . setPostalCode ( \"80331\" ); address . setCountry ( \"DE\" ); AccountHolder accountHolder = new AccountHolder ( \"John\" , \"Doe\" ); accountHolder . setDateOfBirth ( \"1986-01-01\" ); accountHolder . setAddress ( address ); cardPayment . setAccountHolder ( accountHolder ); // IP address cardPayment . setIpAddress ( \"127.0.0.1\" ); // loyalty card LoyaltyCard loyaltyCard = new LoyaltyCard (); loyaltyCard . setUserId ( \"7fe54e18-f251-4130-9f6b-0536afc86ee7\" ); loyaltyCard . setCardId ( \"32be4a4e-67ca-e911-b9b9-005056ab64a1\" ); cardPayment . setLoyaltyCard ( loyaltyCard ); // notifications Notification notification = new Notification (); notification . setUrl ( \"https://server.com\" ); List < Notification > listOfNotifications = new ArrayList <>(); listOfNotifications . add ( notification ); Notifications notifications = new Notifications (); notifications . setNotifications ( listOfNotifications ); notifications . setFormat ( Notifications . FORMAT_JSON ); cardPayment . setNotifications ( notifications ); // order OrderItem orderItem = new OrderItem (); orderItem . setName ( \"Bicycle\" ); orderItem . setDescription ( \"Best product ever\" ); orderItem . setArticleNumber ( \"BC1234\" ); orderItem . setAmount ( new RequestedAmount ( new BigDecimal ( 800 ), \"EUR\" )); orderItem . setQuantity ( 1 ); orderItem . setTaxRate ( new BigDecimal ( 20 )); ArrayList < OrderItem > orderItems = new ArrayList <>(); orderItems . add ( orderItem ); cardPayment . setOrderDetail ( \"Test product\" ); cardPayment . setOrderNumber ( \"DE11111111\" ); cardPayment . setOrderItems ( orderItems ); cardPayment . setOrderItems ( orderItems ); // shipping address Shipping shipping = new Shipping (); shipping . setShippingCity ( \"Berlin\" ); shipping . setShippingCountry ( \"DE\" ); shipping . setShippingPostalCode ( \"04001\" ); shipping . setShippingState ( \"Shipped\" ); shipping . setShippingStreet1 ( \"Street 1\" ); shipping . setShippingStreet2 ( \"Street 2 info\" ); shipping . setShippingStreet3 ( \"Street 3 info\" ); shipping . setShippingMethod ( ShippingMethod . SHIPPING_TO_STORE ); cardPayment . setShippingAddress ( shipping ); // descriptor cardPayment . setDescriptor ( \"Demo descriptor\" );","title":"Optional Data"},{"location":"PayPal/","text":"PayPal \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types: debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. authorization-only - verifies the validity of account holder's card, but does not leave an authorized amount. capture-authorization - captures a previously authorized amount from the account holder's card. Must refer to an existing authorization transaction. Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:paypal:4.2.0\" ... } Signature \u00b6 Application shall get signature from server where signature shall be computed. Basic PayPal Payment \u00b6 PayPal requires additional setup of the wd_ecom_paypal_scheme and wd_ecom_paypal_host resources so you can receive responses from PayPal: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_paypal_scheme\" > yourapp </string> <string name= \"wd_ecom_paypal_host\" > result.paypal </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 val paypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = null , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 PayPalPayment payPalPayment = new PayPalPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . setPeriodic ( null ) . setRiskReferenceId ( null ) . build (); Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment ) Recurring PayPal Payment \u00b6 On a basic level, recurring payments have two phases: The initial request, which must include: periodic type set to RECURRING , sequence type set to FIRST . The \"recurring\"/follow-up requests, which must include: periodic type set to RECURRING , sequence type set to SEQUENCE , parentTransactionId and riskReferenceId values from the initial request. So in order to create a recurring payment, you need to: Send a initial request with the appropriate periodic and sequence flags, Save the values of parentTransactionId and riskReferenceId fields generated in this first payment, Reference these values in the follow-up request, then send it with appropriate periodic and sequence flags. Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // first payment val firstPeriodicType = Periodic () firstPeriodicType . periodicType = PeriodicType . RECURRING . value firstPeriodicType . sequenceType = SequenceType . FIRST . value val firstPaypalPayment = PayPalPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = firstPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ) ... // handle first result private var parentTransactionId : String ? = null private var riskReferenceId : String ? = null override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val paymentSdkResponse = data ?. getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment ?. parentTransactionId riskReferenceId = paymentSdkResponse . payment ?. riskReferenceId } } // second payment using parentTransactionId and riskReferenceId val secondPeriodicType = Periodic () secondPeriodicType . periodicType = PeriodicType . RECURRING . value secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value val secondPaypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = secondPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // first payment Periodic firstPeriodicType = new Periodic (); firstPeriodicType . periodicType = PeriodicType . RECURRING . value ; firstPeriodicType . sequenceType = SequenceType . FIRST . value ; PayPalPayment firstPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , firstPeriodicType , null ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ); ... // handle first result private String parentTransactionId = null ; private String riskReferenceId = null ; protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment . getParentTransactionId (); riskReferenceId = paymentSdkResponse . payment . getRiskReferenceId (); } } // second payment using parentTransactionId and riskReferenceId; Periodic secondPeriodicType = new Periodic (); secondPeriodicType . periodicType = PeriodicType . RECURRING . value ; secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value ; PayPalPayment secondPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , secondPeriodicType , riskReferenceId ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment ); Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 Changing Text Size \u00b6 To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"PayPal"},{"location":"PayPal/#paypal","text":"","title":"PayPal"},{"location":"PayPal/#supported-transaction-types","text":"This payment method supports the following transaction types: debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. authorization-only - verifies the validity of account holder's card, but does not leave an authorized amount. capture-authorization - captures a previously authorized amount from the account holder's card. Must refer to an existing authorization transaction.","title":"Supported Transaction Types"},{"location":"PayPal/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:paypal:4.2.0\" ... }","title":"Module Dependency"},{"location":"PayPal/#signature","text":"Application shall get signature from server where signature shall be computed.","title":"Signature"},{"location":"PayPal/#basic-paypal-payment","text":"PayPal requires additional setup of the wd_ecom_paypal_scheme and wd_ecom_paypal_host resources so you can receive responses from PayPal: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_paypal_scheme\" > yourapp </string> <string name= \"wd_ecom_paypal_host\" > result.paypal </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 val paypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = null , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 PayPalPayment payPalPayment = new PayPalPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( paymentState . getAmount ()) . setCurrency ( currency ) . setPeriodic ( null ) . setRiskReferenceId ( null ) . build (); Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( paypalPayment )","title":"Basic PayPal Payment"},{"location":"PayPal/#recurring-paypal-payment","text":"On a basic level, recurring payments have two phases: The initial request, which must include: periodic type set to RECURRING , sequence type set to FIRST . The \"recurring\"/follow-up requests, which must include: periodic type set to RECURRING , sequence type set to SEQUENCE , parentTransactionId and riskReferenceId values from the initial request. So in order to create a recurring payment, you need to: Send a initial request with the appropriate periodic and sequence flags, Save the values of parentTransactionId and riskReferenceId fields generated in this first payment, Reference these values in the follow-up request, then send it with appropriate periodic and sequence flags. Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // first payment val firstPeriodicType = Periodic () firstPeriodicType . periodicType = PeriodicType . RECURRING . value firstPeriodicType . sequenceType = SequenceType . FIRST . value val firstPaypalPayment = PayPalPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = firstPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ) ... // handle first result private var parentTransactionId : String ? = null private var riskReferenceId : String ? = null override fun onActivityResult ( requestCode : Int , resultCode : Int , data : Intent ?) { super . onActivityResult ( requestCode , resultCode , data ) val paymentSdkResponse = data ?. getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ) if ( paymentSdkResponse is PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment ?. parentTransactionId riskReferenceId = paymentSdkResponse . payment ?. riskReferenceId } } // second payment using parentTransactionId and riskReferenceId val secondPeriodicType = Periodic () secondPeriodicType . periodicType = PeriodicType . RECURRING . value secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value val secondPaypalPayment = PayPalPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , periodic = secondPeriodicType , riskReferenceId = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // first payment Periodic firstPeriodicType = new Periodic (); firstPeriodicType . periodicType = PeriodicType . RECURRING . value ; firstPeriodicType . sequenceType = SequenceType . FIRST . value ; PayPalPayment firstPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , firstPeriodicType , null ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( firstPaypalPayment ); ... // handle first result private String parentTransactionId = null ; private String riskReferenceId = null ; protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ); Serializable paymentSdkResponse = data . getSerializableExtra ( Client . EXTRA_PAYMENT_SDK_RESPONSE ); if ( paymentSdkResponse instanceof PaymentResponse ) { parentTransactionId = paymentSdkResponse . payment . getParentTransactionId (); riskReferenceId = paymentSdkResponse . payment . getRiskReferenceId (); } } // second payment using parentTransactionId and riskReferenceId; Periodic secondPeriodicType = new Periodic (); secondPeriodicType . periodicType = PeriodicType . RECURRING . value ; secondPeriodicType . sequenceType = SequenceType . SEQUENCE . value ; PayPalPayment secondPaypalPayment = PayPalPayment ( signature , requestID , merchantID , transactionType , amount , currency , secondPeriodicType , riskReferenceId ); new Client ( this , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( secondPaypalPayment );","title":"Recurring PayPal Payment"},{"location":"PayPal/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"PayPal/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"PayPal/#changing-fonts","text":"To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1","title":"Changing Fonts"},{"location":"PayPal/#changing-text-size","text":"To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Changing Text Size"},{"location":"SEPA/","text":"SEPA \u00b6 Supported Transaction Types \u00b6 debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. pending-debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. The pending status indicates that additional processing/approval is required before the transaction is cleared. Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation ( \"com.wirecard.ecom:sepa:4.2.0\" ) { // exclude module: 'play-services-vision' } ... } To disable the IBAN scanner feature, uncomment the exclude module line. When adding/removing this feature, perform a full clean build. If you intend to use Card Payments module together with the SEPA Direct Debit module (with IBAN scanner), you must enable/disable it in both modules. Signature \u00b6 Application shall get signature from server where signature shall be computed. Simple SEPA Payment \u00b6 This is a code example for a basic SEPA payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val sepaPayment = SepaPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , creditorId = null , mandateId = null , mandateSignedDate = null , merchantName = \"JOHN DOE\" , dueDate = null , periodic = null , B2B = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 sepaPayment = new SepaPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setMerchantName ( \"JOHN DOE\" ) . build (); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ); You can use Builder to create the payment object and set additional properties afterwards. Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Changing Text Size \u00b6 To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField . Customizing SEPA Payments \u00b6 Color Resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_iban_3 11 - wd_ecom_camera_blue","title":"SEPA"},{"location":"SEPA/#sepa","text":"","title":"SEPA"},{"location":"SEPA/#supported-transaction-types","text":"debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. authorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. pending-debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. The pending status indicates that additional processing/approval is required before the transaction is cleared.","title":"Supported Transaction Types"},{"location":"SEPA/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation ( \"com.wirecard.ecom:sepa:4.2.0\" ) { // exclude module: 'play-services-vision' } ... } To disable the IBAN scanner feature, uncomment the exclude module line. When adding/removing this feature, perform a full clean build. If you intend to use Card Payments module together with the SEPA Direct Debit module (with IBAN scanner), you must enable/disable it in both modules.","title":"Module Dependency"},{"location":"SEPA/#signature","text":"Application shall get signature from server where signature shall be computed.","title":"Signature"},{"location":"SEPA/#simple-sepa-payment","text":"This is a code example for a basic SEPA payment: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val sepaPayment = SepaPayment ( signature = signature , requestTimeStamp = timestamp , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , creditorId = null , mandateId = null , mandateSignedDate = null , merchantName = \"JOHN DOE\" , dueDate = null , periodic = null , B2B = null ) Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 sepaPayment = new SepaPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setMerchantName ( \"JOHN DOE\" ) . build (); new Client ( context , \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( sepaPayment ); You can use Builder to create the payment object and set additional properties afterwards.","title":"Simple SEPA Payment"},{"location":"SEPA/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"SEPA/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"SEPA/#changing-fonts","text":"To change fonts, add the font path to the payment object: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment )","title":"Changing Fonts"},{"location":"SEPA/#changing-text-size","text":"To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Changing Text Size"},{"location":"SEPA/#customizing-sepa-payments","text":"Color Resources 1 - wd_ecom_color_main 2 - wd_ecom_color_light 3 - wd_ecom_color_main_alpha80 4 - wd_ecom_color_pay_button_text 5 - wd_ecom_color_toolbar_text 6 - wd_ecom_color_error 7 - wd_ecom_color_main_background Icons 8 - wd_ecom_arrow_back 9 - wd_ecom_cardholder_name 10 - wd_ecom_iban_3 11 - wd_ecom_camera_blue","title":"Customizing SEPA Payments"},{"location":"Theming/","text":"Theming \u00b6 For changing colors within the SDK simply override color values in xml file. Common Color Resources \u00b6 Changing these colors would afect all modules used within SDK. 1 2 3 4 5 6 7 wd_ecom_color_main - colour tint for icons, header and submit button gradient start colour wd_ecom_color_main_light - header and submit button gradient end colour wd_ecom_color_main_alpha80 - text input layout title colour wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text colour wd_ecom_color_main_background - background colour for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Font \u00b6 Simply add font path to payment object as shown in example: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) missing JAVA code example here? Changing Text Size \u00b6 Use dimen attribute wd_ecom_text_size for changing text size within all modules except card field fragment - use wd_ecom_cardfield_text_size .","title":"Theming"},{"location":"Theming/#theming","text":"For changing colors within the SDK simply override color values in xml file.","title":"Theming"},{"location":"Theming/#common-color-resources","text":"Changing these colors would afect all modules used within SDK. 1 2 3 4 5 6 7 wd_ecom_color_main - colour tint for icons, header and submit button gradient start colour wd_ecom_color_main_light - header and submit button gradient end colour wd_ecom_color_main_alpha80 - text input layout title colour wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text colour wd_ecom_color_main_background - background colour for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Common Color Resources"},{"location":"Theming/#changing-font","text":"Simply add font path to payment object as shown in example: 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) missing JAVA code example here?","title":"Changing Font"},{"location":"Theming/#changing-text-size","text":"Use dimen attribute wd_ecom_text_size for changing text size within all modules except card field fragment - use wd_ecom_cardfield_text_size .","title":"Changing Text Size"},{"location":"Zapp/","text":"Zapp \u00b6 With Zapp, there are two payments flow. Whether the customer has a banking application installed on their phone decides which one is used : 1. Banking application is installed - this app is opened after a successful response from Wirecard payment gateway. 2. No banking application - SDK prompts a pop-up informing the user to provide BRN (see explanation below) to a banking application on another device and awaits confirmation. BRN is short for Basket Reference Number, a unique temporary code provided by Zapp (and conveyed to the customer by the merchant) which identifies the order which is being paid. Supported Transaction Types \u00b6 debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. Zapp transaction and delivery types \u00b6 Transaction types: BILLPT - Bill payment PAYMT - Retail item payment INVOICE - Invoice payment DONATIONS - Donation payment Delivery types: COLLST - Store collection. The consumer chose to collect the goods from the store personally. DELTAD - Delivery to address. The Consumer chose to have the goods delivered to the specified address. DIGDEL - Digital delivery. The Consumer chose to receive items electronically. SERVICE - Service provided. For SMB transactions where there is no need for a delivery address F2F - Face-to-face transactions. Primarily for use with an SMB transaction. NONE - No delivery Module Dependency \u00b6 Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:zapp:4.2.0\" ... } Signature \u00b6 Application shall get signature from server where signature shall be computed. Simple Zapp Payment \u00b6 Zapp requires additional setup of the wd_ecom_zapp_scheme and wd_ecom_zapp_host resources so you can receive responses from Zapp: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_zapp_host\" > yourapp </string> <string name= \"wd_ecom_zapp_scheme\" > open.pbba </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val zappPayment = ZappPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , zappTransactionType = \"PAYMT\" , zappDeliveryType = \"SERVICE\" , ) zappPayment . ipAddress = \"127.0.0.1\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout = 60 ). startPayment ( zappPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ZappPayment zappPayment = new ZappPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setZappTransactionType ( \"PAYMNT\" ) . setZappDeliveryType ( \"SERVICE\" ) . build (); zappPayment . setIpAddress ( \"127.0.0.1\" ); new Client ( context , \"https://api-test.wirecard.com\" , 30 ). startPayment ( zappPayment ); Customizing Visuals \u00b6 To change colors within the SDK, override the default color values in the .xml file. Color Resources \u00b6 Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line Changing Fonts \u00b6 To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1 Changing Text Size \u00b6 To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Zapp"},{"location":"Zapp/#zapp","text":"With Zapp, there are two payments flow. Whether the customer has a banking application installed on their phone decides which one is used : 1. Banking application is installed - this app is opened after a successful response from Wirecard payment gateway. 2. No banking application - SDK prompts a pop-up informing the user to provide BRN (see explanation below) to a banking application on another device and awaits confirmation. BRN is short for Basket Reference Number, a unique temporary code provided by Zapp (and conveyed to the customer by the merchant) which identifies the order which is being paid.","title":"Zapp"},{"location":"Zapp/#supported-transaction-types","text":"debit - charges the specified amount from the account holder's bank account and marks it for immediate transfer.","title":"Supported Transaction Types"},{"location":"Zapp/#zapp-transaction-and-delivery-types","text":"Transaction types: BILLPT - Bill payment PAYMT - Retail item payment INVOICE - Invoice payment DONATIONS - Donation payment Delivery types: COLLST - Store collection. The consumer chose to collect the goods from the store personally. DELTAD - Delivery to address. The Consumer chose to have the goods delivered to the specified address. DIGDEL - Digital delivery. The Consumer chose to receive items electronically. SERVICE - Service provided. For SMB transactions where there is no need for a delivery address F2F - Face-to-face transactions. Primarily for use with an SMB transaction. NONE - No delivery","title":"Zapp transaction and delivery types"},{"location":"Zapp/#module-dependency","text":"Edit your build.gradle file accordingly: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 android { compileSdkVersion 27 defaultConfig { minSdkVersion 16 targetSdkVersion 27 ... } ... } repositories { mavenCentral () maven { url \"https://dl.bintray.com/wirecard/ecom-android\" } } dependencies { ... implementation \"com.wirecard.ecom:zapp:4.2.0\" ... }","title":"Module Dependency"},{"location":"Zapp/#signature","text":"Application shall get signature from server where signature shall be computed.","title":"Signature"},{"location":"Zapp/#simple-zapp-payment","text":"Zapp requires additional setup of the wd_ecom_zapp_scheme and wd_ecom_zapp_host resources so you can receive responses from Zapp: 1 2 3 4 5 6 <resources> ... <string name= \"wd_ecom_zapp_host\" > yourapp </string> <string name= \"wd_ecom_zapp_scheme\" > open.pbba </string> ... </resources> Then you can go ahead and create the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val zappPayment = ZappPayment ( signature = signature , requestID = requestID , merchantAccountId = merchantID , transactionType = transactionType , amount = amount , currency = currency , zappTransactionType = \"PAYMT\" , zappDeliveryType = \"SERVICE\" , ) zappPayment . ipAddress = \"127.0.0.1\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout = 60 ). startPayment ( zappPayment ) Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ZappPayment zappPayment = new ZappPayment . Builder () . setSignature ( signature ) . setRequestId ( requestID ) . setMerchantAccountId ( merchantID ) . setTransactionType ( transactionType ) . setAmount ( amount ) . setCurrency ( currency ) . setZappTransactionType ( \"PAYMNT\" ) . setZappDeliveryType ( \"SERVICE\" ) . build (); zappPayment . setIpAddress ( \"127.0.0.1\" ); new Client ( context , \"https://api-test.wirecard.com\" , 30 ). startPayment ( zappPayment );","title":"Simple Zapp Payment"},{"location":"Zapp/#customizing-visuals","text":"To change colors within the SDK, override the default color values in the .xml file.","title":"Customizing Visuals"},{"location":"Zapp/#color-resources","text":"Changing any of these will affect every module used in the SDK: wd_ecom_color_main - color tint for icons, header and submit button gradient start color wd_ecom_color_main_light - header and submit button gradient end color wd_ecom_color_main_alpha80 - text input layout title color wd_ecom_color_toolbar_text - toolbar text and back arrow tint wd_ecom_color_pay_button_text - pay button text color wd_ecom_color_main_background - background color for main view wd_ecom_color_error - used for all text input layouts to modify error text color including the edit text line","title":"Color Resources"},{"location":"Zapp/#changing-fonts","text":"To change fonts, add the font path to the payment object: Kotlin 1 2 3 4 5 6 7 8 9 10 11 12 13 val cardPayment = CardPayment ( signature , timestamp , requestID , merchantID , transactionType , amount , currency ) cardPayment . fontPath = \"fonts/myFont.otf\" Client ( context = this , url = \"https://api-test.wirecard.com\" , requestTimeout ). startPayment ( cardPayment ) Java 1","title":"Changing Fonts"},{"location":"Zapp/#changing-text-size","text":"To change the text size use dimensional attribute wd_ecom_text_size . This affects all the modules, except cardField .","title":"Changing Text Size"}]}